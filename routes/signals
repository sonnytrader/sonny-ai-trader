const express = require('express');
const { signal } = require('../models/signal');
const { authenticateToken } = require('../middleware/auth');

const router = express.Router();

// ALPHASON CRYPTO - 3 TEKNİK STRATEJİ
const strategies = {
  // 1. KIRILIM STRATEJİSİ
  breakout: async (symbol) => {
    try {
      const ccxt = require('ccxt');
      
      const exchange = new ccxt.binance();
      const ohlcv = await exchange.fetchOHLCV(symbol, '15m', undefined, 100);
      
      const highs = ohlcv.map(c => c[2]);
      const lows = ohlcv.map(c => c[3]);
      const closes = ohlcv.map(c => c[4]);
      const volumes = ohlcv.map(c => c[5]);
      
      // Destek/Direnç hesapla
      const resistance = Math.max(...highs.slice(-20));
      const support = Math.min(...lows.slice(-20));
      const currentPrice = closes[closes.length - 1];
      const currentVolume = volumes[volumes.length - 1];
      const avgVolume = volumes.slice(-20).reduce((a, b) => a + b) / 20;
      
      // Volume onayı ile kırılım tespiti
      if (currentPrice > resistance * 0.998 && currentVolume > avgVolume * 1.5) {
        return { 
          direction: 'LONG', 
          confidence: 75,
          entry: parseFloat(currentPrice),
          tp: parseFloat(currentPrice * 1.02),
          sl: parseFloat(currentPrice * 0.98)
        };
      } else if (currentPrice < support * 1.002 && currentVolume > avgVolume * 1.5) {
        return { 
          direction: 'SHORT', 
          confidence: 70,
          entry: parseFloat(currentPrice),
          tp: parseFloat(currentPrice * 0.98),
          sl: parseFloat(currentPrice * 1.02)
        };
      }
      
      return null;
    } catch (error) {
      console.error('Breakout strategy error:', error);
      return null;
    }
  },
  
  // 2. PUMP/DETECTOR  
  pumpdetect: async (symbol) => {
    try {
      const ccxt = require('ccxt');
      
      const exchange = new ccxt.binance();
      const ohlcv = await exchange.fetchOHLCV(symbol, '5m', undefined, 50);
      
      const volumes = ohlcv.map(c => c[5]);
      const closes = ohlcv.map(c => c[4]);
      const highs = ohlcv.map(c => c[2]);
      const lows = ohlcv.map(c => c[3]);
      
      const currentVolume = volumes[volumes.length - 1];
      const avgVolume = volumes.slice(-20).reduce((a, b) => a + b) / 20;
      const priceChange = ((closes[closes.length - 1] - closes[closes.length - 2]) / closes[closes.length - 2]) * 100;
      const priceRange = (highs[highs.length - 1] - lows[lows.length - 1]) / lows[lows.length - 1] * 100;
      
      // Ani hacim artışı + fiyat hareketi + yüksek volatilite
      if (currentVolume > avgVolume * 3 && Math.abs(priceChange) > 2 && priceRange > 3) {
        const direction = priceChange > 0 ? 'LONG' : 'SHORT';
        const currentPrice = closes[closes.length - 1];
        
        return { 
          direction: direction, 
          confidence: 80,
          entry: parseFloat(currentPrice),
          tp: direction === 'LONG' ? parseFloat(currentPrice * 1.03) : parseFloat(currentPrice * 0.97),
          sl: direction === 'LONG' ? parseFloat(currentPrice * 0.97) : parseFloat(currentPrice * 1.03)
        };
      }
      
      return null;
    } catch (error) {
      console.error('PumpDetect strategy error:', error);
      return null;
    }
  },
  
  // 3. RSI+MACD KOMBO
  rsimacd: async (symbol) => {
    try {
      const ccxt = require('ccxt');
      const { RSI, MACD } = require('technicalindicators');
      
      const exchange = new ccxt.binance();
      const ohlcv = await exchange.fetchOHLCV(symbol, '1h', undefined, 100);
      const closes = ohlcv.map(c => c[4]);
      
      // RSI hesapla
      const rsi = RSI.calculate({ values: closes, period: 14 });
      const currentRSI = rsi[rsi.length - 1];
      
      // MACD hesapla
      const macd = MACD.calculate({
        values: closes,
        fastPeriod: 12,
        slowPeriod: 26,
        signalPeriod: 9,
        SimpleMAOscillator: false,
        SimpleMASignal: false
      });
      
      const currentMACD = macd[macd.length - 1];
      const currentPrice = closes[closes.length - 1];
      
      // Strateji kuralları
      if (currentRSI < 30 && currentMACD?.MACD > currentMACD?.signal) {
        return { 
          direction: 'LONG', 
          confidence: 85,
          entry: parseFloat(currentPrice),
          tp: parseFloat(currentPrice * 1.015),
          sl: parseFloat(currentPrice * 0.985)
        };
      } else if (currentRSI > 70 && currentMACD?.MACD < currentMACD?.signal) {
        return { 
          direction: 'SHORT', 
          confidence: 80,
          entry: parseFloat(currentPrice),
          tp: parseFloat(currentPrice * 0.985),
          sl: parseFloat(currentPrice * 1.015)
        };
      }
      
      return null;
    } catch (error) {
      console.error('RSI+MACD strategy error:', error);
      return null;
    }
  }
};

// Sinyalleri getir
router.get('/', authenticateToken, async (req, res) => {
  try {
    const userStrategy = req.user.strategy || 'breakout';
    const symbols = ['BTC/USDT', 'ETH/USDT', 'ADA/USDT', 'DOT/USDT', 'LINK/USDT'];
    const signals = [];

    for (let symbol of symbols) {
      const signalData = await strategies[userStrategy](symbol);
      if (signalData) {
        const signalWithData = {
          symbol,
          strategy: userStrategy,
          ...signalData
        };
        signals.push(signalWithData);

        // Save to database
        await signal.create({
          userId: req.user.id,
          symbol,
          direction: signalData.direction,
          entry: signalData.entry,
          tp: signalData.tp,
          sl: signalData.sl,
          confidence: signalData.confidence,
          strategy: userStrategy
        });
      }
    }

    res.json({ success: true, signals });
  } catch (error) {
    console.error('Sinyal hatası:', error);
    res.status(500).json({ success: false, error: 'Sinyaller alınamadı' });
  }
});

// Strateji güncelle
router.put('/strategy', authenticateToken, async (req, res) => {
  try {
    const { strategy } = req.body;
    
    if (!strategies[strategy]) {
      return res.status(400).json({ success: false, error: 'Geçersiz strateji' });
    }

    await req.user.update({ strategy });
    
    res.json({ 
      success: true, 
      message: 'Strateji güncellendi', 
      strategy 
    });
  } catch (error) {
    console.error('Strateji güncelleme hatası:', error);
    res.status(500).json({ success: false, error: 'Strateji güncellenemedi' });
  }
});

// Stratejileri dışa aktar
router.strategies = strategies;

module.exports = router;
